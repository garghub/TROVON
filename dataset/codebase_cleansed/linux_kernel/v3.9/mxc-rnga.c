static int mxc_rnga_data_present(struct hwrng *rng, int wait)\r\n{\r\nint i;\r\nstruct mxc_rng *mxc_rng = container_of(rng, struct mxc_rng, rng);\r\nfor (i = 0; i < 20; i++) {\r\nint level = (__raw_readl(mxc_rng->mem + RNGA_STATUS) &\r\nRNGA_STATUS_LEVEL_MASK) >> 8;\r\nif (level || !wait)\r\nreturn !!level;\r\nudelay(10);\r\n}\r\nreturn 0;\r\n}\r\nstatic int mxc_rnga_data_read(struct hwrng *rng, u32 * data)\r\n{\r\nint err;\r\nu32 ctrl;\r\nstruct mxc_rng *mxc_rng = container_of(rng, struct mxc_rng, rng);\r\n*data = __raw_readl(mxc_rng->mem + RNGA_OUTPUT_FIFO);\r\nerr = __raw_readl(mxc_rng->mem + RNGA_STATUS) & RNGA_STATUS_ERROR_INT;\r\nif (err) {\r\ndev_dbg(mxc_rng->dev, "Error while reading random number!\n");\r\nctrl = __raw_readl(mxc_rng->mem + RNGA_CONTROL);\r\n__raw_writel(ctrl | RNGA_CONTROL_CLEAR_INT,\r\nmxc_rng->mem + RNGA_CONTROL);\r\nreturn 0;\r\n} else\r\nreturn 4;\r\n}\r\nstatic int mxc_rnga_init(struct hwrng *rng)\r\n{\r\nu32 ctrl, osc;\r\nstruct mxc_rng *mxc_rng = container_of(rng, struct mxc_rng, rng);\r\nctrl = __raw_readl(mxc_rng->mem + RNGA_CONTROL);\r\n__raw_writel(ctrl & ~RNGA_CONTROL_SLEEP, mxc_rng->mem + RNGA_CONTROL);\r\nosc = __raw_readl(mxc_rng->mem + RNGA_STATUS);\r\nif (osc & RNGA_STATUS_OSC_DEAD) {\r\ndev_err(mxc_rng->dev, "RNGA Oscillator is dead!\n");\r\nreturn -ENODEV;\r\n}\r\nctrl = __raw_readl(mxc_rng->mem + RNGA_CONTROL);\r\n__raw_writel(ctrl | RNGA_CONTROL_GO, mxc_rng->mem + RNGA_CONTROL);\r\nreturn 0;\r\n}\r\nstatic void mxc_rnga_cleanup(struct hwrng *rng)\r\n{\r\nu32 ctrl;\r\nstruct mxc_rng *mxc_rng = container_of(rng, struct mxc_rng, rng);\r\nctrl = __raw_readl(mxc_rng->mem + RNGA_CONTROL);\r\n__raw_writel(ctrl & ~RNGA_CONTROL_GO, mxc_rng->mem + RNGA_CONTROL);\r\n}\r\nstatic int __init mxc_rnga_probe(struct platform_device *pdev)\r\n{\r\nint err = -ENODEV;\r\nstruct resource *res, *mem;\r\nstruct mxc_rng *mxc_rng;\r\nmxc_rng = devm_kzalloc(&pdev->dev, sizeof(struct mxc_rng),\r\nGFP_KERNEL);\r\nif (!mxc_rng)\r\nreturn -ENOMEM;\r\nmxc_rng->dev = &pdev->dev;\r\nmxc_rng->rng.name = "mxc-rnga";\r\nmxc_rng->rng.init = mxc_rnga_init;\r\nmxc_rng->rng.cleanup = mxc_rnga_cleanup,\r\nmxc_rng->rng.data_present = mxc_rnga_data_present,\r\nmxc_rng->rng.data_read = mxc_rnga_data_read,\r\nmxc_rng->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(mxc_rng->clk)) {\r\ndev_err(&pdev->dev, "Could not get rng_clk!\n");\r\nerr = PTR_ERR(mxc_rng->clk);\r\ngoto out;\r\n}\r\nclk_prepare_enable(mxc_rng->clk);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\nerr = -ENOENT;\r\ngoto err_region;\r\n}\r\nmem = request_mem_region(res->start, resource_size(res), pdev->name);\r\nif (mem == NULL) {\r\nerr = -EBUSY;\r\ngoto err_region;\r\n}\r\nmxc_rng->mem = ioremap(res->start, resource_size(res));\r\nif (!mxc_rng->mem) {\r\nerr = -ENOMEM;\r\ngoto err_ioremap;\r\n}\r\nerr = hwrng_register(&mxc_rng->rng);\r\nif (err) {\r\ndev_err(&pdev->dev, "MXC RNGA registering failed (%d)\n", err);\r\ngoto err_ioremap;\r\n}\r\ndev_info(&pdev->dev, "MXC RNGA Registered.\n");\r\nreturn 0;\r\nerr_ioremap:\r\nrelease_mem_region(res->start, resource_size(res));\r\nerr_region:\r\nclk_disable_unprepare(mxc_rng->clk);\r\nout:\r\nreturn err;\r\n}\r\nstatic int __exit mxc_rnga_remove(struct platform_device *pdev)\r\n{\r\nstruct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nstruct mxc_rng *mxc_rng = platform_get_drvdata(pdev);\r\nhwrng_unregister(&mxc_rng->rng);\r\niounmap(mxc_rng->mem);\r\nrelease_mem_region(res->start, resource_size(res));\r\nclk_disable_unprepare(mxc_rng->clk);\r\nreturn 0;\r\n}\r\nstatic int __init mod_init(void)\r\n{\r\nreturn platform_driver_probe(&mxc_rnga_driver, mxc_rnga_probe);\r\n}\r\nstatic void __exit mod_exit(void)\r\n{\r\nplatform_driver_unregister(&mxc_rnga_driver);\r\n}
